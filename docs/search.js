window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "tessa", "modulename": "tessa", "type": "module", "doc": "<h1 id=\"tessa-simple-hassle-free-access-to-price-information-of-financial-assets\">tessa \u2013 simple, hassle-free access to price information of financial assets \ud83d\udcc9\ud83e\udd13\ud83d\udcc8</h1>\n\n<p>tessa is a Python library to help you <strong>easily search asset identifiers</strong> (e.g.,\ntickers) and <strong>retrieve price information</strong> for assets from different sources such as\nYahoo or Coingecko. It takes care of the different APIs, caching, rate limiting, and\nother hassles.</p>\n\n<p>tessa provides a <strong>Symbol class that encapsulates nicely the methods relevant for a\nsymbol</strong>. tessa also provides functionality to <strong>manage collections of symbols</strong>, store\nand load them, and extend their functionality.</p>\n\n<p>Finally, tessa makes sure to be nice to the sites being accessed and tries to <strong>prevent\nusers from being blocked by 429 rate limiting errors</strong> by 1) caching results upon\nretrieval and 2) keeping track of request timestamps and waiting appropriate amounts of\ntime if necessary.</p>\n\n<p><a href=\"https://ymyke.github.io/tessa/tessa.html\">\u2192 Check out the full documentation. \ud83d\udcd6</a></p>\n\n<h2 id=\"how-to-use\">How to use</h2>\n\n<p>Here's a longer example that quickly shows all aspects of the library. Refer to\nsubmodules <a href=\"tessa/symbol.html\">symbol</a>, <a href=\"tessa/search.html\">search</a>, and\n<a href=\"tessa/price.html\">price</a> for more information.</p>\n\n<ul>\n<li>Imports:</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"kn\">from</span> <span class=\"nn\">tessa</span> <span class=\"kn\">import</span> <span class=\"n\">Symbol</span><span class=\"p\">,</span> <span class=\"n\">SymbolCollection</span><span class=\"p\">,</span> <span class=\"n\">search</span>\n</code></pre></div>\n\n<ul>\n<li>Create a symbol for MSFT and access some functions:</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"n\">s1</span> <span class=\"o\">=</span> <span class=\"n\">Symbol</span><span class=\"p\">(</span><span class=\"s2\">&quot;MSFT&quot;</span><span class=\"p\">)</span>         <span class=\"c1\"># will use &quot;yahoo&quot; as the default source</span>\n<span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"n\">price_latest</span><span class=\"p\">()</span>           <span class=\"c1\"># get latest price</span>\n</code></pre></div>\n\n<ul>\n<li>Create another symbol from a bloomberg ticker as it is used by Yahoo Finance:</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"n\">s2</span> <span class=\"o\">=</span> <span class=\"n\">Symbol</span><span class=\"p\">(</span><span class=\"s2\">&quot;SREN.SW&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">s2</span><span class=\"o\">.</span><span class=\"n\">price_point</span><span class=\"p\">(</span><span class=\"s2\">&quot;2022-06-30&quot;</span><span class=\"p\">)</span>    <span class=\"c1\"># get price at specific point in time</span>\n</code></pre></div>\n\n<ul>\n<li>Create a symbol from the coingecko source with an id as it is used by coingecko:</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"n\">s3</span> <span class=\"o\">=</span> <span class=\"n\">Symbol</span><span class=\"p\">(</span><span class=\"s2\">&quot;bitcoin&quot;</span><span class=\"p\">,</span> <span class=\"n\">source</span><span class=\"o\">=</span><span class=\"s2\">&quot;coingecko&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">s3</span><span class=\"o\">.</span><span class=\"n\">price_graph</span><span class=\"p\">()</span>            <span class=\"c1\"># show price graph</span>\n</code></pre></div>\n\n<ul>\n<li>Search for a more crypto ticker on coingecko:</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">search</span><span class=\"p\">(</span><span class=\"s2\">&quot;GAME&quot;</span><span class=\"p\">)</span>        <span class=\"c1\"># search and print search result summary</span>\n<span class=\"n\">filtered</span> <span class=\"o\">=</span> <span class=\"n\">res</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"n\">source</span><span class=\"o\">=</span><span class=\"s2\">&quot;coingecko&quot;</span><span class=\"p\">)</span>  <span class=\"c1\"># filter results</span>\n<span class=\"n\">filtered</span><span class=\"o\">.</span><span class=\"n\">p</span><span class=\"p\">()</span>                <span class=\"c1\"># print summary of filtered results</span>\n<span class=\"n\">filtered</span><span class=\"o\">.</span><span class=\"n\">buckets</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">symbols</span> <span class=\"c1\"># review the best bucket in the filtered results</span>\n<span class=\"n\">s4</span> <span class=\"o\">=</span> <span class=\"n\">filtered</span><span class=\"o\">.</span><span class=\"n\">buckets</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">symbols</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span>   <span class=\"c1\"># our symbol is the 3rd in that list</span>\n<span class=\"n\">s4</span><span class=\"o\">.</span><span class=\"n\">price_history</span><span class=\"p\">()</span>          <span class=\"c1\"># get entire history</span>\n</code></pre></div>\n\n<ul>\n<li>Build a collection of several symbols and use the collection to retrieve symbols:</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"n\">sc</span> <span class=\"o\">=</span> <span class=\"n\">SymbolCollection</span><span class=\"p\">([</span><span class=\"n\">s1</span><span class=\"p\">,</span> <span class=\"n\">s2</span><span class=\"p\">,</span> <span class=\"n\">s3</span><span class=\"p\">,</span> <span class=\"n\">s4</span><span class=\"p\">])</span>\n<span class=\"n\">sc</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">Symbol</span><span class=\"p\">(</span><span class=\"s2\">&quot;AAPL&quot;</span><span class=\"p\">))</span>      <span class=\"c1\"># add another one</span>\n<span class=\"n\">sc</span><span class=\"o\">.</span><span class=\"n\">find_one</span><span class=\"p\">(</span><span class=\"s2\">&quot;SREN&quot;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">price_graph</span><span class=\"p\">()</span>\n</code></pre></div>\n\n<ul>\n<li>Store and load a symbol collection:</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"n\">sc</span><span class=\"o\">.</span><span class=\"n\">save_yaml</span><span class=\"p\">(</span><span class=\"s2\">&quot;my_symbols.yaml&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">sc_new</span> <span class=\"o\">=</span> <span class=\"n\">SymbolCollection</span><span class=\"p\">()</span>\n<span class=\"n\">sc_new</span><span class=\"o\">.</span><span class=\"n\">load_yaml</span><span class=\"p\">(</span><span class=\"s2\">&quot;my_symbols.yaml&quot;</span><span class=\"p\">)</span>\n</code></pre></div>\n\n<ul>\n<li>Use a different currency preference:</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"n\">sc</span><span class=\"o\">.</span><span class=\"n\">find_one</span><span class=\"p\">(</span><span class=\"s2\">&quot;game&quot;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">price_latest</span><span class=\"p\">()</span>  <span class=\"c1\"># will return price in USD</span>\n<span class=\"n\">Symbol</span><span class=\"o\">.</span><span class=\"n\">currency_preference</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;CHF&quot;</span>\n<span class=\"n\">sc</span><span class=\"o\">.</span><span class=\"n\">find_one</span><span class=\"p\">(</span><span class=\"s2\">&quot;game&quot;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">price_latest</span><span class=\"p\">()</span>  <span class=\"c1\"># will return price in CHF</span>\n</code></pre></div>\n\n<p>Note that <code>currency_preference</code> will only have an effect with sources that support it.\nIt is supported for Coingecko but not for Yahoo. So you should always verify the\neffective currency you receive in the result.</p>\n\n<h2 id=\"data-sources\">Data sources</h2>\n\n<p>tessa builds on <a href=\"https://pypi.org/project/yfinance/\">yfinance</a> and\n<a href=\"https://github.com/man-c/pycoingecko\">pycoingecko</a> and offers <strong>a simplified and\nunified interface</strong>. </p>\n\n<p>Why these two sources? Yahoo Finance (via yfinance) is fast and offers an extensive\ndatabase that also contains many non-US markets. Coingecko (via pycoingecko) offers\ngreat access to crypto prices. While Yahoo Finance also offers crypto information,\npycoingecko has the advantage that you can have the prices quoted in many more currency\npreferences (a function that is also exposed via tessa).</p>\n\n<p>More sources can be added in the future. Let me know in the\n<a href=\"https://github.com/ymyke/tessa/issues\">issues</a> of you have a particular request.</p>\n\n<h2 id=\"main-submodules\">Main submodules</h2>\n\n<ul>\n<li><a href=\"tessa/symbol.html\">symbol</a>: working with symbols and symbol collections.</li>\n<li><a href=\"tessa/search.html\">search</a>: searching the different sources.</li>\n<li><a href=\"tessa/price.html\">price</a>: accessing price functions directly instead of via the\n<code>Symbol</code> class.</li>\n<li><a href=\"tessa/sources.html\">sources</a>: if you'd like to add additional sources to the library.</li>\n</ul>\n\n<h2 id=\"how-to-install\">How to install</h2>\n\n<p><code>pip install tessa</code></p>\n\n<h2 id=\"prerequisites\">Prerequisites</h2>\n\n<p>See <code>pyproject.toml</code>. Major prerequisites are the <code>yfinance</code> and <code>pycoingecko</code> packages\nto access finance information as well as the <code>beautifulsoup4</code> package to do some\nscraping for searching on Yahoo Finance.</p>\n\n<h2 id=\"repository\">Repository</h2>\n\n<p><a href=\"https://github.com/ymyke/tessa\">https://github.com/ymyke/tessa</a></p>\n\n<h2 id=\"future-work\">Future Work</h2>\n\n<p>This is an initial version. There are a number of ideas on how to extend. Please leave\nyour suggestions and comments in the <a href=\"https://github.com/ymyke/tessa/issues\">Issues\nsection</a>.</p>\n\n<h2 id=\"on-terminology\">On terminology</h2>\n\n<p>I'm using symbol instead of ticker because a ticker is mainly used for stock on stock\nmarkets, whereas tessa is inteded to be used for any kind of financial assets, e.g. also\ncrypto.</p>\n\n<h2 id=\"other-noteworthy-libraries\">Other noteworthy libraries</h2>\n\n<ul>\n<li><a href=\"https://github.com/ymyke/strela\">strela</a>: A python package for financial alerts.</li>\n<li><a href=\"https://github.com/ymyke/pypme\">pypme</a>: A Python package for PME (Public Market\nEquivalent) calculation.</li>\n</ul>\n\n<h2 id=\"on-investpy-as-a-data-source\">On investpy as a data source</h2>\n\n<p>Tessa used to use the <a href=\"https://github.com/alvarobartt/investpy\">investpy package</a> as the\nmain source of information until mid 2022 until investing.com introduced Cloudflare,\nwhich broke access by investpy. \ud83d\ude16 It is currently unclear if investpy will be available\nagain in the future. <a href=\"https://github.com/alvarobartt/investpy/issues/600\">You can follow the developments in issue\n600.</a> The old tessa/investpy code is\nstill available in the <a href=\"https://github.com/ymyke/tessa/tree/add-symbols-based-on-investpy\">add-symbols-based-on-investpy\nbranch</a>.</p>\n"}, {"fullname": "tessa.price", "modulename": "tessa.price", "type": "module", "doc": "<h1 id=\"retrieving-price-information\">Retrieving price information</h1>\n\n<p>Main functions:</p>\n\n<ul>\n<li><code>tessa.price.price.price_history</code>: Retrieve the full history of an asset as a\ndataframe.</li>\n<li><code>tessa.price.price.price_point_strict</code>: Get an asset's price at a certain point in\ntime. Fail if no price found.</li>\n<li><code>tessa.price.price.price_point</code>: Same, but find the nearest price if the given point\nin time has no</li>\n<li><code>tessa.price.price.price_latest</code>: Get an asset's latest price.</li>\n</ul>\n\n<p>Example use:</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">tessa</span> <span class=\"kn\">import</span> <span class=\"n\">price_history</span><span class=\"p\">,</span> <span class=\"n\">price_point</span><span class=\"p\">,</span> <span class=\"n\">price_latest</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">df</span><span class=\"p\">,</span> <span class=\"n\">currency</span> <span class=\"o\">=</span> <span class=\"n\">price_history</span><span class=\"p\">(</span><span class=\"s2\">&quot;AAPL&quot;</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">price_point</span><span class=\"p\">(</span><span class=\"s2\">&quot;SAP.DE&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;2015-01-01&quot;</span><span class=\"p\">)</span>         <span class=\"c1\"># will return price at 2015-01-02</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">price_point_strict</span><span class=\"p\">(</span><span class=\"s2\">&quot;SAP.DE&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;2015-01-01&quot;</span><span class=\"p\">)</span>  <span class=\"c1\"># will raise a KeyError</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">price_latest</span><span class=\"p\">(</span><span class=\"s2\">&quot;ethereum&quot;</span><span class=\"p\">,</span> <span class=\"n\">source</span><span class=\"o\">=</span><span class=\"s2\">&quot;coingecko&quot;</span><span class=\"p\">,</span> <span class=\"n\">currency_preference</span><span class=\"o\">=</span><span class=\"s2\">&quot;CHF&quot;</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">price_latest</span><span class=\"p\">(</span><span class=\"s2\">&quot;ETH-EUR&quot;</span><span class=\"p\">,</span> <span class=\"n\">source</span><span class=\"o\">=</span><span class=\"s2\">&quot;yahoo&quot;</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">price_latest</span><span class=\"p\">(</span><span class=\"s2\">&quot;ethereum&quot;</span><span class=\"p\">,</span> <span class=\"n\">source</span><span class=\"o\">=</span><span class=\"s2\">&quot;yahoo&quot;</span><span class=\"p\">)</span>    <span class=\"c1\"># error b/c symbol not found on yahoo</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">price_latest</span><span class=\"p\">(</span><span class=\"s2\">&quot;ETH-EUR&quot;</span><span class=\"p\">,</span> <span class=\"n\">source</span><span class=\"o\">=</span><span class=\"s2\">&quot;coingecko&quot;</span><span class=\"p\">)</span> <span class=\"c1\"># error b/c symbol not found on coingecko</span>\n</code></pre></div>\n"}, {"fullname": "tessa.price.coingecko", "modulename": "tessa.price.coingecko", "type": "module", "doc": "<p>Everything coingecko-related (other than search).</p>\n"}, {"fullname": "tessa.price.coingecko.dataframify_price_list", "modulename": "tessa.price.coingecko", "qualname": "dataframify_price_list", "type": "function", "doc": "<p>Turn price list returned by Coingecko API into a pricing dataframe in the form\nthat we use.</p>\n", "signature": "(prices: list) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "tessa.price.coingecko.get_price_history", "modulename": "tessa.price.coingecko", "qualname": "get_price_history", "type": "function", "doc": "<p>Get price history for a given cryptocurrency.</p>\n", "signature": "(\n    query: str,\n    currency_preference: str = 'USD'\n) -> tessa.price.types.PriceHistory", "funcdef": "def"}, {"fullname": "tessa.price.price", "modulename": "tessa.price.price", "type": "module", "doc": "<p>Retrieve price information.</p>\n"}, {"fullname": "tessa.price.price.price_history", "modulename": "tessa.price.price", "qualname": "price_history", "type": "function", "doc": "<p>Get price history and return <code>PriceHistory</code>, i.e., a tuple of a dataframe with\nthe price history and the effective currency. Note that the effective currency\nreturned might differ from the currency_preference.</p>\n\n<ul>\n<li><code>query</code>: A query string that makes sense in combination with the source. E.g.,\n\"BTC-USD\" for \"yahoo\" or \"bitcoin\" for \"coingecko\".</li>\n<li><code>source</code>: The source to query. Defaults to \"yahoo\".</li>\n<li><code>currency_preference</code>: The currency to the prices should be returned in; defaults\nto \"USD\". The effective currency might differ and will be returned in the second\nreturn value.</li>\n</ul>\n", "signature": "(\n    query: str,\n    source: Literal['yahoo', 'coingecko'] = 'yahoo',\n    currency_preference: str = 'USD'\n) -> tessa.price.types.PriceHistory", "funcdef": "def"}, {"fullname": "tessa.price.price.price_point", "modulename": "tessa.price.price", "qualname": "price_point", "type": "function", "doc": "<p>Return the price at a given point in time given by <code>when</code>. Look for the closest\npoint in time if the exact point in time is not found. Returns a <code>PricePoint</code>, i.e.,\na tuple of the price, the effective timestamp of the price, and the currency.</p>\n\n<p>Arguments other than <code>when</code> are the same as with <code>price_history</code>.</p>\n\n<p>Example call:</p>\n\n<pre><code>price_point(\"AAPL\", \"2020-01-01\")\n</code></pre>\n", "signature": "(\n    query: str,\n    when: Union[str, pandas._libs.tslibs.timestamps.Timestamp],\n    source: Literal['yahoo', 'coingecko'] = 'yahoo',\n    currency_preference: str = 'USD'\n) -> tessa.price.types.PricePoint", "funcdef": "def"}, {"fullname": "tessa.price.price.price_point_strict", "modulename": "tessa.price.price", "qualname": "price_point_strict", "type": "function", "doc": "<p>Same as <code>price_point</code> but will return either the price at the exact point in time\nor raise a KeyError.</p>\n", "signature": "(\n    query: str,\n    when: str,\n    source: Literal['yahoo', 'coingecko'] = 'yahoo',\n    currency_preference: str = 'USD'\n) -> tessa.price.types.PricePoint", "funcdef": "def"}, {"fullname": "tessa.price.price.price_latest", "modulename": "tessa.price.price", "qualname": "price_latest", "type": "function", "doc": "<p>Same as <code>price_point</code> but will return the latest price.</p>\n", "signature": "(\n    query: str,\n    source: Literal['yahoo', 'coingecko'] = 'yahoo',\n    currency_preference: str = 'USD'\n) -> tessa.price.types.PricePoint", "funcdef": "def"}, {"fullname": "tessa.price.types", "modulename": "tessa.price.types", "type": "module", "doc": "<p>Price-related types.</p>\n"}, {"fullname": "tessa.price.types.PriceHistory", "modulename": "tessa.price.types", "qualname": "PriceHistory", "type": "class", "doc": "<p>PriceHistory(df, currency)</p>\n", "bases": "builtins.tuple"}, {"fullname": "tessa.price.types.PriceHistory.__init__", "modulename": "tessa.price.types", "qualname": "PriceHistory.__init__", "type": "function", "doc": "<p>Create new instance of PriceHistory(df, currency)</p>\n", "signature": "(_cls, df: pandas.core.frame.DataFrame, currency: str)", "funcdef": "def"}, {"fullname": "tessa.price.types.PriceHistory.df", "modulename": "tessa.price.types", "qualname": "PriceHistory.df", "type": "variable", "doc": "<p>Alias for field number 0</p>\n", "annotation": ": pandas.core.frame.DataFrame"}, {"fullname": "tessa.price.types.PriceHistory.currency", "modulename": "tessa.price.types", "qualname": "PriceHistory.currency", "type": "variable", "doc": "<p>Alias for field number 1</p>\n", "annotation": ": str"}, {"fullname": "tessa.price.types.PricePoint", "modulename": "tessa.price.types", "qualname": "PricePoint", "type": "class", "doc": "<p>PricePoint(when, price, currency)</p>\n", "bases": "builtins.tuple"}, {"fullname": "tessa.price.types.PricePoint.__init__", "modulename": "tessa.price.types", "qualname": "PricePoint.__init__", "type": "function", "doc": "<p>Create new instance of PricePoint(when, price, currency)</p>\n", "signature": "(\n    _cls,\n    when: pandas._libs.tslibs.timestamps.Timestamp,\n    price: float,\n    currency: str\n)", "funcdef": "def"}, {"fullname": "tessa.price.types.PricePoint.when", "modulename": "tessa.price.types", "qualname": "PricePoint.when", "type": "variable", "doc": "<p>Alias for field number 0</p>\n", "annotation": ": pandas._libs.tslibs.timestamps.Timestamp"}, {"fullname": "tessa.price.types.PricePoint.price", "modulename": "tessa.price.types", "qualname": "PricePoint.price", "type": "variable", "doc": "<p>Alias for field number 1</p>\n", "annotation": ": float"}, {"fullname": "tessa.price.types.PricePoint.currency", "modulename": "tessa.price.types", "qualname": "PricePoint.currency", "type": "variable", "doc": "<p>Alias for field number 2</p>\n", "annotation": ": str"}, {"fullname": "tessa.price.types.SymbolNotFoundError", "modulename": "tessa.price.types", "qualname": "SymbolNotFoundError", "type": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n", "bases": "builtins.Exception"}, {"fullname": "tessa.price.types.SymbolNotFoundError.__init__", "modulename": "tessa.price.types", "qualname": "SymbolNotFoundError.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    source: Literal['yahoo', 'coingecko'],\n    query: str,\n    *args,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "tessa.price.types.CurrencyPreferenceNotFoundError", "modulename": "tessa.price.types", "qualname": "CurrencyPreferenceNotFoundError", "type": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n", "bases": "builtins.Exception"}, {"fullname": "tessa.price.types.CurrencyPreferenceNotFoundError.__init__", "modulename": "tessa.price.types", "qualname": "CurrencyPreferenceNotFoundError.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    source: Literal['yahoo', 'coingecko'],\n    cur_pref: str,\n    *args,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "tessa.price.yahoo", "modulename": "tessa.price.yahoo", "type": "module", "doc": "<p>Everything Yahoo-Finance-related (other than search).</p>\n\n<p>Note that yfinance has some inconsistent/strange error behavior. E.g., when a ticker\ndoesn't exist:</p>\n\n<ul>\n<li><code>history()</code> will return an empty dataframe (but with all the column headers as usual)\nand print \"No data found, symbol may be delisted\" to stdout.</li>\n<li><code>get_info()</code> will simply return a json such as this one: <code>{'regularMarketPrice': None,\n'preMarketPrice': None, 'logo_url': ''}</code>.\nThis module will streamline this behavior and raise a <code>RuntimeError</code> in such cases.</li>\n</ul>\n"}, {"fullname": "tessa.price.yahoo.START_FROM", "modulename": "tessa.price.yahoo", "qualname": "START_FROM", "type": "variable", "doc": "<p>Adjust this date if you need to get historical data further in the past. Note that\nextending this date will lead to increased load on the Yahoo Finance servers.</p>\n", "default_value": " = '2000-01-01'"}, {"fullname": "tessa.price.yahoo.get_ticker_info", "modulename": "tessa.price.yahoo", "qualname": "get_ticker_info", "type": "function", "doc": "<p>Get the meta information for a ticker and return it as a dict.</p>\n", "signature": "(query: str) -> dict", "funcdef": "def"}, {"fullname": "tessa.price.yahoo.get_price_history", "modulename": "tessa.price.yahoo", "qualname": "get_price_history", "type": "function", "doc": "<p>Get price history for a given query. Note that <code>currency_preference</code> will be\nignored since Yahoo Finance returns each ticker in the one currency that is set for\nthat ticker.</p>\n", "signature": "(\n    query: str,\n    currency_preference: str = 'USD'\n) -> tessa.price.types.PriceHistory", "funcdef": "def"}, {"fullname": "tessa.search", "modulename": "tessa.search", "type": "module", "doc": "<h1 id=\"searching-symbols\">Searching symbols</h1>\n\n<p>Main function is <code>tessa.search.search.search</code>, which will return a\n<code>tessa.search.search_result.SearchResult</code>, offering all kinds of useful functionality.</p>\n\n<p>Example use:</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"kn\">from</span> <span class=\"nn\">tessa</span> <span class=\"kn\">import</span> <span class=\"n\">search</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">search</span><span class=\"p\">(</span><span class=\"s2\">&quot;roche&quot;</span><span class=\"p\">)</span>                 <span class=\"c1\"># search</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">r</span><span class=\"o\">.</span><span class=\"n\">p</span><span class=\"p\">()</span>                               <span class=\"c1\"># print result statistics</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">r</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"n\">exchange</span><span class=\"o\">=</span><span class=\"s2\">&quot;EBS&quot;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">symbols</span>    <span class=\"c1\"># filter and get list of resulting symbols</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">search</span><span class=\"p\">(</span><span class=\"s2\">&quot;jenny&quot;</span><span class=\"p\">)</span>                 <span class=\"c1\"># another search</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">r</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"n\">source</span><span class=\"o\">=</span><span class=\"s2\">&quot;coingecko&quot;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">symbols</span> <span class=\"c1\"># filter for source (i.e., yahoo or coingecko)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">search</span><span class=\"p\">(</span><span class=\"s2\">&quot;carbon&quot;</span><span class=\"p\">)</span>                <span class=\"c1\"># yet another search</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">r</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"n\">source</span><span class=\"o\">=</span><span class=\"s2\">&quot;yahoo&quot;</span><span class=\"p\">,</span> <span class=\"nb\">type</span><span class=\"o\">=</span><span class=\"s2\">&quot;ETF&quot;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">symbols</span> <span class=\"c1\"># filter for source and type</span>\n</code></pre></div>\n"}, {"fullname": "tessa.search.coingecko", "modulename": "tessa.search.coingecko", "type": "module", "doc": "<p>Everything related to searching via coingecko.</p>\n"}, {"fullname": "tessa.search.coingecko.get_symbol_map", "modulename": "tessa.search.coingecko", "qualname": "get_symbol_map", "type": "function", "doc": "<p>Get the symbol map. Separate function to use caching, so the API doesn't get\nhit too often.</p>\n", "signature": "() -> list", "funcdef": "def"}, {"fullname": "tessa.search.coingecko.coingecko_search", "modulename": "tessa.search.coingecko", "qualname": "coingecko_search", "type": "function", "doc": "<p>Find coingecko ids that match <code>query</code> somehow. Returns <code>SearchResult</code>.</p>\n", "signature": "(query: str) -> tessa.search.search_result.SearchResult", "funcdef": "def"}, {"fullname": "tessa.search.search", "modulename": "tessa.search.search", "type": "module", "doc": "<p>Unified search.</p>\n"}, {"fullname": "tessa.search.search.search", "modulename": "tessa.search.search", "qualname": "search", "type": "function", "doc": "<p>Unified search function. Returns a <code>tessa.search.SearchResult</code>.</p>\n\n<ul>\n<li><code>query</code>: The string to search for. (Note that this query attribute has a different\nsemantics to the query attribute in the <code>Symbol</code> class.)</li>\n<li><code>silent</code>: No print output if True.</li>\n</ul>\n", "signature": "(\n    query: str,\n    silent: bool = False\n) -> tessa.search.search_result.SearchResult", "funcdef": "def"}, {"fullname": "tessa.search.search_result", "modulename": "tessa.search.search_result", "type": "module", "doc": "<p>Everything related to search results, especially the <code>SearchResult</code> class.</p>\n"}, {"fullname": "tessa.search.search_result.matches_entire_name_or_alias", "modulename": "tessa.search.search_result", "qualname": "matches_entire_name_or_alias", "type": "function", "doc": "<p>Try to match the complete name or one of the aliases completely. E.g.:\n<code>matches_entire_name_or_alias(\"eth\", Symbol(\"ETH\")) &gt; 0</code>.</p>\n", "signature": "(query: str, symbol: tessa.symbol.symbol.Symbol) -> int", "funcdef": "def"}, {"fullname": "tessa.search.search_result.matches_word_boundary", "modulename": "tessa.search.search_result", "qualname": "matches_word_boundary", "type": "function", "doc": "<p>Try to match a complete word in name, aliases, or query. E.g.:\n<code>matches_word_boundary(\"eth\", Symbol(\"ETHW\", aliases=[\"PoW ETH\"])) &gt; 0</code>.</p>\n", "signature": "(query: str, symbol: tessa.symbol.symbol.Symbol) -> int", "funcdef": "def"}, {"fullname": "tessa.search.search_result.matches_inanyway", "modulename": "tessa.search.search_result", "qualname": "matches_inanyway", "type": "function", "doc": "<p>Try to match anywhere in name, aliases, or query. E.g.:\n<code>matches_inanyway(\"eth\", Symbol(\"TOGETHER\")) &gt; 0</code>.</p>\n", "signature": "(query: str, symbol: tessa.symbol.symbol.Symbol) -> int", "funcdef": "def"}, {"fullname": "tessa.search.search_result.Bucket", "modulename": "tessa.search.search_result", "qualname": "Bucket", "type": "class", "doc": "<p>A bucket is a set of results of a certain quality level in a larger search result. A\nbucket has a name and a list of symbols that belong into that bucket.</p>\n", "bases": "builtins.tuple"}, {"fullname": "tessa.search.search_result.Bucket.__init__", "modulename": "tessa.search.search_result", "qualname": "Bucket.__init__", "type": "function", "doc": "<p>Create new instance of Bucket(name, symbols)</p>\n", "signature": "(_cls, name: str, symbols: List[tessa.symbol.symbol.Symbol])", "funcdef": "def"}, {"fullname": "tessa.search.search_result.Bucket.name", "modulename": "tessa.search.search_result", "qualname": "Bucket.name", "type": "variable", "doc": "<p>Alias for field number 0</p>\n", "annotation": ": str"}, {"fullname": "tessa.search.search_result.Bucket.symbols", "modulename": "tessa.search.search_result", "qualname": "Bucket.symbols", "type": "variable", "doc": "<p>Alias for field number 1</p>\n", "annotation": ": List[tessa.symbol.symbol.Symbol]"}, {"fullname": "tessa.search.search_result.bucketize", "modulename": "tessa.search.search_result", "qualname": "bucketize", "type": "function", "doc": "<p>Split a list of <code>Symbol</code>s into buckets based on how well a symbol matches the\n<code>query</code>.</p>\n\n<p>(We're not using <code>itertools.groupby</code> here bc we need empty lists for empty buckets,\nwhich <code>groupby</code> doesn't provide.)</p>\n", "signature": "(\n    query: str,\n    symbols: List[tessa.symbol.symbol.Symbol]\n) -> List[tessa.search.search_result.Bucket]", "funcdef": "def"}, {"fullname": "tessa.search.search_result.create_sort_key_for_query", "modulename": "tessa.search.search_result", "qualname": "create_sort_key_for_query", "type": "function", "doc": "<p>Create a sort key function that classifies a <code>Symbol</code> based on <code>query</code>.</p>\n", "signature": "(query: str) -> Callable", "funcdef": "def"}, {"fullname": "tessa.search.search_result.remove_duplicates", "modulename": "tessa.search.search_result", "qualname": "remove_duplicates", "type": "function", "doc": "<p>Return a list in which every symbol is unique. Two symbols are considered\nequivalent if they match in <code>query</code> and <code>source</code>. Regardless of whether their names\nare the same or different.</p>\n\n<p>Note further that several symbols can have the same name but still be considered\ndifferent if they differ in any of <code>query</code> or <code>source</code>.</p>\n", "signature": "(\n    symbols: List[tessa.symbol.symbol.Symbol]\n) -> List[tessa.symbol.symbol.Symbol]", "funcdef": "def"}, {"fullname": "tessa.search.search_result.SearchResult", "modulename": "tessa.search.search_result", "qualname": "SearchResult", "type": "class", "doc": "<p>Manages a search result consisting of a list of <code>Symbol</code>s. Removes duplicates,\nbucketizes, sorts and offers methods to filter and print statistics.</p>\n\n<p>(Design note 1: <code>SearchResult</code> has no relationship with <code>SymbolCollection</code> because\nthe purposes of the two classes are very different and because they have different\nequality definitions for symbols.</p>\n\n<p>Design note 2: <code>SearchResult</code> and <code>SymbolCollection</code> have different definitions of\nequality between symbols: <code>SearchResult</code> considers 2 symbols to be equal if they are\nequal in <code>query</code> and <code>source</code>, regardless of whether they have the same name or not.\nA <code>SymbolCollection</code> does not have a definition of equality, but it does enforce\nthat names are unique.)</p>\n\n<p>Example use:</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"kn\">from</span> <span class=\"nn\">tessa</span> <span class=\"kn\">import</span> <span class=\"n\">search</span>\n<span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">search</span><span class=\"p\">(</span><span class=\"s2\">&quot;harmony&quot;</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Review results:</span>\n<span class=\"n\">r</span><span class=\"o\">.</span><span class=\"n\">p</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Get the 1 symbol from source &quot;coingecko&quot; in the best bucket (i.e., bucket 0):</span>\n<span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">r</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"n\">source</span><span class=\"o\">=</span><span class=\"s2\">&quot;coingecko&quot;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">buckets</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">symbols</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">price_latest</span><span class=\"p\">()</span>\n</code></pre></div>\n"}, {"fullname": "tessa.search.search_result.SearchResult.__init__", "modulename": "tessa.search.search_result", "qualname": "SearchResult.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, query: str, symbols: List[tessa.symbol.symbol.Symbol])", "funcdef": "def"}, {"fullname": "tessa.search.search_result.SearchResult.query", "modulename": "tessa.search.search_result", "qualname": "SearchResult.query", "type": "variable", "doc": "<p>The query that produced the results here.</p>\n", "annotation": ": str"}, {"fullname": "tessa.search.search_result.SearchResult.symbols", "modulename": "tessa.search.search_result", "qualname": "SearchResult.symbols", "type": "variable", "doc": "<p>List of symbols in this result. Always deduplicated and sorted.</p>\n", "annotation": ": List[tessa.symbol.symbol.Symbol]"}, {"fullname": "tessa.search.search_result.SearchResult.buckets", "modulename": "tessa.search.search_result", "qualname": "SearchResult.buckets", "type": "variable", "doc": "<p>List of buckets after bucketizing the symbols.</p>\n", "annotation": ": List[tessa.search.search_result.Bucket]"}, {"fullname": "tessa.search.search_result.SearchResult.filter_history", "modulename": "tessa.search.search_result", "qualname": "SearchResult.filter_history", "type": "variable", "doc": "<p>The filters that have been applied to get to this result.</p>\n", "annotation": ": List[str]"}, {"fullname": "tessa.search.search_result.SearchResult.add_symbols", "modulename": "tessa.search.search_result", "qualname": "SearchResult.add_symbols", "type": "function", "doc": "<p>Add symbols. Removes duplicates, sorts, and bucketizes after adding.</p>\n", "signature": "(\n    self,\n    symbols: List[tessa.symbol.symbol.Symbol]\n) -> tessa.search.search_result.SearchResult", "funcdef": "def"}, {"fullname": "tessa.search.search_result.SearchResult.filter", "modulename": "tessa.search.search_result", "qualname": "SearchResult.filter", "type": "function", "doc": "<p>Filter for arbitrary attribute-value-pairs (e.g., <code>source=\"coingecko\"</code> or\n<code>exchange=\"ebs\"</code>) and return a new <code>SearchResult</code> with the results after the\nfiltering. Also updates the filter history.</p>\n", "signature": "(self, **kwargs) -> tessa.search.search_result.SearchResult", "funcdef": "def"}, {"fullname": "tessa.search.search_result.SearchResult.p", "modulename": "tessa.search.search_result", "qualname": "SearchResult.p", "type": "function", "doc": "<p>Convenience method to print str rep.</p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "tessa.search.yahoo", "modulename": "tessa.search.yahoo", "type": "module", "doc": "<p>Get Yahoo Finance search results via scraping.</p>\n"}, {"fullname": "tessa.search.yahoo.create_headers", "modulename": "tessa.search.yahoo", "qualname": "create_headers", "type": "function", "doc": "<p></p>\n", "signature": "(url: str) -> dict", "funcdef": "def"}, {"fullname": "tessa.search.yahoo.get_tables", "modulename": "tessa.search.yahoo", "qualname": "get_tables", "type": "function", "doc": "<p>Retrieve search page for query and at offset, parse all the tables into\ndataframes and return that list.</p>\n", "signature": "(query: str, offset: int) -> List[pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "tessa.search.yahoo.get_search_results", "modulename": "tessa.search.yahoo", "qualname": "get_search_results", "type": "function", "doc": "<p>Get all search results as a dataframe. Returns an empty dataframe if there are no\nresults.</p>\n", "signature": "(query: str) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "tessa.search.yahoo.dataframe_to_symbols", "modulename": "tessa.search.yahoo", "qualname": "dataframe_to_symbols", "type": "function", "doc": "<p>Convert a search result dataframe to a list of <code>Symbol</code>s.</p>\n", "signature": "(df: pandas.core.frame.DataFrame) -> List[tessa.symbol.symbol.Symbol]", "funcdef": "def"}, {"fullname": "tessa.search.yahoo.yahoo_search", "modulename": "tessa.search.yahoo", "qualname": "yahoo_search", "type": "function", "doc": "<p>Search on Yahoo Finance.</p>\n", "signature": "(query: str) -> tessa.search.search_result.SearchResult", "funcdef": "def"}, {"fullname": "tessa.sources", "modulename": "tessa.sources", "type": "module", "doc": "<h1 id=\"managing-different-data-sources\">Managing different data sources</h1>\n\n<p>A <code>tessa.sources.sources.Source</code> ties together all the functionality and state related\nto a source such as Yahoo or Coingecko.</p>\n\n<p><code>tessa.sources.rate_limiter.RateLimiter</code> takes care of rate limiting for a source.</p>\n\n<p>All known sources are specified in <code>tessa.sources.sources_directory</code>.</p>\n"}, {"fullname": "tessa.sources.low_level_rate_limiter", "modulename": "tessa.sources.low_level_rate_limiter", "type": "module", "doc": "<p>Rate Limiter -- makes sure we don't hit the APIs too often by waiting by default and\nwaiting exponentially if a 429 error is encountered.</p>\n\n<p>The goal is to never run into errors in the first place, because some sites like\ncoingecko.com take substantial time until they allow-list a blocked IP address again.\nThat is also why we can't use a library such das Tenacity here.</p>\n\n<p>Note that this module is no longer used by the package. But I left it in here anyway,\nbecause it might come in handy for people who use the pycoingecko or some other library\nin other ways than through this package.</p>\n\n<p>Usage: Import the module and call <code>setup_guards()</code>.</p>\n"}, {"fullname": "tessa.sources.low_level_rate_limiter.create_guard", "modulename": "tessa.sources.low_level_rate_limiter", "qualname": "create_guard", "type": "function", "doc": "<p>Create a guard.</p>\n", "signature": "(\n    func: <built-in function callable>,\n    guard: dict\n) -> <built-in function callable>", "funcdef": "def"}, {"fullname": "tessa.sources.low_level_rate_limiter.setup_guards", "modulename": "tessa.sources.low_level_rate_limiter", "qualname": "setup_guards", "type": "function", "doc": "<p>Set up guards.</p>\n", "signature": "() -> None", "funcdef": "def"}, {"fullname": "tessa.sources.rate_limiter", "modulename": "tessa.sources.rate_limiter", "type": "module", "doc": "<p>Rate Limiter -- makes sure we don't hit the APIs too often by making sure a minimum\namount of time has elapsed between calls to an API.</p>\n\n<p>The goal is to never run into errors in the first place, b/c some sites take substantial\ntime until it allow-lists a blocked IP address again. That is also why we can't use a\nlibrary such das Tenacity here.</p>\n"}, {"fullname": "tessa.sources.rate_limiter.RateLimiter", "modulename": "tessa.sources.rate_limiter", "qualname": "RateLimiter", "type": "class", "doc": "<p>Encapsulates state and stats of a rate limiter object.</p>\n"}, {"fullname": "tessa.sources.rate_limiter.RateLimiter.__init__", "modulename": "tessa.sources.rate_limiter", "qualname": "RateLimiter.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    wait_seconds: float,\n    last_call: datetime.datetime = DateTime(1900, 1, 1, 0, 0, 0, tzinfo=Timezone('UTC')),\n    count_all_calls: int = 0,\n    count_limited_calls: int = 0\n)", "funcdef": "def"}, {"fullname": "tessa.sources.rate_limiter.RateLimiter.wait_seconds", "modulename": "tessa.sources.rate_limiter", "qualname": "RateLimiter.wait_seconds", "type": "variable", "doc": "<p>Enforce this amount of seconds between subsequent calls.</p>\n", "annotation": ": float"}, {"fullname": "tessa.sources.rate_limiter.RateLimiter.last_call", "modulename": "tessa.sources.rate_limiter", "qualname": "RateLimiter.last_call", "type": "variable", "doc": "<p>Keeps track of last call's timestamp.</p>\n", "annotation": ": datetime.datetime", "default_value": " = DateTime(1900, 1, 1, 0, 0, 0, tzinfo=Timezone('UTC'))"}, {"fullname": "tessa.sources.rate_limiter.RateLimiter.count_all_calls", "modulename": "tessa.sources.rate_limiter", "qualname": "RateLimiter.count_all_calls", "type": "variable", "doc": "<p>Number of total calls.</p>\n", "annotation": ": int", "default_value": " = 0"}, {"fullname": "tessa.sources.rate_limiter.RateLimiter.count_limited_calls", "modulename": "tessa.sources.rate_limiter", "qualname": "RateLimiter.count_limited_calls", "type": "variable", "doc": "<p>Number of calls that triggered some waiting.</p>\n", "annotation": ": int", "default_value": " = 0"}, {"fullname": "tessa.sources.rate_limiter.RateLimiter.reset", "modulename": "tessa.sources.rate_limiter", "qualname": "RateLimiter.reset", "type": "function", "doc": "<p>Reset state and stats.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "tessa.sources.rate_limiter.RateLimiter.rate_limit", "modulename": "tessa.sources.rate_limiter", "qualname": "RateLimiter.rate_limit", "type": "function", "doc": "<p>Enforce the minimum wait time as specified in <code>wait_seconds</code>.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "tessa.sources.sources", "modulename": "tessa.sources.sources", "type": "module", "doc": "<p>Source class and related functions.</p>\n"}, {"fullname": "tessa.sources.sources.Source", "modulename": "tessa.sources.sources", "qualname": "Source", "type": "class", "doc": "<p>A <code>Source</code> encapsulates everything related to a source such as Yahoo or\nCoingecko.</p>\n"}, {"fullname": "tessa.sources.sources.Source.__init__", "modulename": "tessa.sources.sources", "qualname": "Source.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    get_price_history: Callable,\n    get_search_results: Callable,\n    rate_limiter: tessa.sources.rate_limiter.RateLimiter\n)", "funcdef": "def"}, {"fullname": "tessa.sources.sources.Source.get_price_history", "modulename": "tessa.sources.sources", "qualname": "Source.get_price_history", "type": "variable", "doc": "<p>Callback to retrieve price history.</p>\n", "annotation": ": Callable"}, {"fullname": "tessa.sources.sources.Source.get_search_results", "modulename": "tessa.sources.sources", "qualname": "Source.get_search_results", "type": "variable", "doc": "<p>Callback to retrieve search results.</p>\n", "annotation": ": Callable"}, {"fullname": "tessa.sources.sources.Source.rate_limiter", "modulename": "tessa.sources.sources", "qualname": "Source.rate_limiter", "type": "variable", "doc": "<p>Rate limiter object.</p>\n", "annotation": ": tessa.sources.rate_limiter.RateLimiter"}, {"fullname": "tessa.sources.sources.get_source", "modulename": "tessa.sources.sources", "qualname": "get_source", "type": "function", "doc": "<p>Get a specific source.</p>\n", "signature": "(name: Literal['yahoo', 'coingecko']) -> tessa.sources.sources.Source", "funcdef": "def"}, {"fullname": "tessa.sources.sources.get_all_sources", "modulename": "tessa.sources.sources", "qualname": "get_all_sources", "type": "function", "doc": "<p>Get all the known sources.</p>\n", "signature": "() -> Generator", "funcdef": "def"}, {"fullname": "tessa.sources.sources.reset_rate_limiters", "modulename": "tessa.sources.sources", "qualname": "reset_rate_limiters", "type": "function", "doc": "<p>Reset the rate limiters of all sources.</p>\n", "signature": "() -> None", "funcdef": "def"}, {"fullname": "tessa.sources.sources_directory", "modulename": "tessa.sources.sources_directory", "type": "module", "doc": "<p>The directory (i.e., dictionary) of all know sources. To be accessed via the\nfunctions in <code>tessa.sources.sources</code>. This module is factored out so the directory can\nbe imported late within functions in order to prevent circular dependencies.</p>\n"}, {"fullname": "tessa.sources.sources_directory.SOURCES_DIRECTORY", "modulename": "tessa.sources.sources_directory", "qualname": "SOURCES_DIRECTORY", "type": "variable", "doc": "<p></p>\n", "annotation": ": Final[Dict[Literal['yahoo', 'coingecko'], tessa.sources.sources.Source]]", "default_value": " = {'yahoo': Source(get_price_history=<function get_price_history>, get_search_results=<function yahoo_search>, rate_limiter=RateLimiter(wait_seconds=0.5, last_call=DateTime(1900, 1, 1, 0, 0, 0, tzinfo=Timezone('UTC')), count_all_calls=0, count_limited_calls=0)), 'coingecko': Source(get_price_history=<function get_price_history>, get_search_results=<function coingecko_search>, rate_limiter=RateLimiter(wait_seconds=2.5, last_call=DateTime(1900, 1, 1, 0, 0, 0, tzinfo=Timezone('UTC')), count_all_calls=0, count_limited_calls=0))}"}, {"fullname": "tessa.sources.sourcetype", "modulename": "tessa.sources.sourcetype", "type": "module", "doc": "<p><code>SourceType</code> is a literal type with all known sources; used for type hinting and to\nsupport autocomplete suggestions.</p>\n"}, {"fullname": "tessa.symbol", "modulename": "tessa.symbol", "type": "module", "doc": "<h1 id=\"working-with-symbols\">Working with Symbols</h1>\n\n<p>The main class is <code>tessa.symbol.symbol.Symbol</code>, which encapsulates all the information\nand functionality around symbols. A <code>tessa.symbol.symbolcollection.SymbolCollection</code>\nmanages a collection of symbols including save and load functionality.</p>\n\n<p>Example use:</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"kn\">from</span> <span class=\"nn\">tessa</span> <span class=\"kn\">import</span> <span class=\"n\">Symbol</span><span class=\"p\">,</span> <span class=\"n\">SymbolCollection</span>\n<span class=\"n\">s1</span> <span class=\"o\">=</span> <span class=\"n\">Symbol</span><span class=\"p\">(</span><span class=\"s2\">&quot;MSFT&quot;</span><span class=\"p\">)</span>                 <span class=\"c1\"># will use &quot;yahoo&quot; as the default source</span>\n<span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"n\">price_latest</span><span class=\"p\">()</span>                   <span class=\"c1\"># get latest price</span>\n<span class=\"n\">sc</span> <span class=\"o\">=</span> <span class=\"n\">SymbolCollection</span><span class=\"p\">([</span><span class=\"n\">s1</span><span class=\"p\">])</span>         <span class=\"c1\"># create collection</span>\n<span class=\"n\">sc</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">Symbol</span><span class=\"p\">(</span><span class=\"s2\">&quot;ethereum&quot;</span><span class=\"p\">,</span> <span class=\"n\">source</span><span class=\"o\">=</span><span class=\"s2\">&quot;coingecko&quot;</span><span class=\"p\">))</span>       <span class=\"c1\"># add another symbol</span>\n<span class=\"n\">sc</span><span class=\"o\">.</span><span class=\"n\">find_one</span><span class=\"p\">(</span><span class=\"s2\">&quot;ethereum&quot;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">price_graph</span><span class=\"p\">(</span><span class=\"n\">monthsback</span><span class=\"o\">=</span><span class=\"mi\">600</span><span class=\"p\">)</span>  <span class=\"c1\"># graph of 10 past yearss</span>\n<span class=\"n\">sc</span><span class=\"o\">.</span><span class=\"n\">save_yaml</span><span class=\"p\">(</span><span class=\"s2\">&quot;my_symbols.yaml&quot;</span><span class=\"p\">)</span>     <span class=\"c1\"># save</span>\n</code></pre></div>\n\n<p><code>tessa.symbol.extended_symbol.ExtendedSymbol</code> shows how the <code>Symbol</code> class can be\nextended.</p>\n"}, {"fullname": "tessa.symbol.extended_symbol", "modulename": "tessa.symbol.extended_symbol", "type": "module", "doc": "<p>An example of how to extend the Symbol class with more information and functionality.</p>\n"}, {"fullname": "tessa.symbol.extended_symbol.ExtendedSymbol", "modulename": "tessa.symbol.extended_symbol", "qualname": "ExtendedSymbol", "type": "class", "doc": "<p>ExtendedSymbol class. Adds more information and functionality to the Symbol\nclass.</p>\n", "bases": "tessa.symbol.symbol.Symbol"}, {"fullname": "tessa.symbol.extended_symbol.ExtendedSymbol.__init__", "modulename": "tessa.symbol.extended_symbol", "qualname": "ExtendedSymbol.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    name: str,\n    query: Optional[str] = None,\n    source: Literal['yahoo', 'coingecko'] = 'yahoo',\n    aliases: list[str] = <factory>,\n    description: Optional[str] = None,\n    country: Optional[Literal['andorra', 'united arab emirates', 'afghanistan', 'antigua and barbuda', 'anguilla', 'albania', 'armenia', 'angola', 'antarctica', 'argentina', 'american samoa', 'austria', 'australia', 'aruba', '\u00e5land', 'azerbaijan', 'bosnia and herzegovina', 'barbados', 'bangladesh', 'belgium', 'burkina faso', 'bulgaria', 'bahrain', 'burundi', 'benin', 'saint barth\u00e9lemy', 'bermuda', 'brunei', 'bolivia', 'bonaire', 'brazil', 'bahamas', 'bhutan', 'bouvet island', 'botswana', 'belarus', 'belize', 'canada', 'cocos [keeling] islands', 'democratic republic of the congo', 'central african republic', 'republic of the congo', 'switzerland', 'ivory coast', 'cook islands', 'chile', 'cameroon', 'china', 'colombia', 'costa rica', 'cuba', 'cape verde', 'curacao', 'christmas island', 'cyprus', 'czech republic', 'germany', 'djibouti', 'denmark', 'dominica', 'dominican republic', 'algeria', 'ecuador', 'estonia', 'egypt', 'western sahara', 'eritrea', 'spain', 'ethiopia', 'finland', 'fiji', 'falkland islands', 'micronesia', 'faroe islands', 'france', 'gabon', 'united kingdom', 'grenada', 'georgia', 'french guiana', 'guernsey', 'ghana', 'gibraltar', 'greenland', 'gambia', 'guinea', 'guadeloupe', 'equatorial guinea', 'greece', 'south georgia and the south sandwich islands', 'guatemala', 'guam', 'guinea-bissau', 'guyana', 'hong kong', 'heard island and mcdonald islands', 'honduras', 'croatia', 'haiti', 'hungary', 'indonesia', 'ireland', 'israel', 'isle of man', 'india', 'british indian ocean territory', 'iraq', 'iran', 'iceland', 'italy', 'jersey', 'jamaica', 'jordan', 'japan', 'kenya', 'kyrgyzstan', 'cambodia', 'kiribati', 'comoros', 'saint kitts and nevis', 'north korea', 'south korea', 'kuwait', 'cayman islands', 'kazakhstan', 'laos', 'lebanon', 'saint lucia', 'liechtenstein', 'sri lanka', 'liberia', 'lesotho', 'lithuania', 'luxembourg', 'latvia', 'libya', 'morocco', 'monaco', 'moldova', 'montenegro', 'saint martin', 'madagascar', 'marshall islands', 'north macedonia', 'mali', 'myanmar [burma]', 'mongolia', 'macao', 'northern mariana islands', 'martinique', 'mauritania', 'montserrat', 'malta', 'mauritius', 'maldives', 'malawi', 'mexico', 'malaysia', 'mozambique', 'namibia', 'new caledonia', 'niger', 'norfolk island', 'nigeria', 'nicaragua', 'netherlands', 'norway', 'nepal', 'nauru', 'niue', 'new zealand', 'oman', 'panama', 'peru', 'french polynesia', 'papua new guinea', 'philippines', 'pakistan', 'poland', 'saint pierre and miquelon', 'pitcairn islands', 'puerto rico', 'palestine', 'portugal', 'palau', 'paraguay', 'qatar', 'r\u00e9union', 'romania', 'serbia', 'russia', 'rwanda', 'saudi arabia', 'solomon islands', 'seychelles', 'sudan', 'sweden', 'singapore', 'saint helena', 'slovenia', 'svalbard and jan mayen', 'slovakia', 'sierra leone', 'san marino', 'senegal', 'somalia', 'suriname', 'south sudan', 's\u00e3o tom\u00e9 and pr\u00edncipe', 'el salvador', 'sint maarten', 'syria', 'swaziland', 'turks and caicos islands', 'chad', 'french southern territories', 'togo', 'thailand', 'tajikistan', 'tokelau', 'east timor', 'turkmenistan', 'tunisia', 'tonga', 'turkey', 'trinidad and tobago', 'tuvalu', 'taiwan', 'tanzania', 'ukraine', 'uganda', 'u.s. minor outlying islands', 'united states', 'uruguay', 'uzbekistan', 'vatican city', 'saint vincent and the grenadines', 'venezuela', 'british virgin islands', 'u.s. virgin islands', 'vietnam', 'vanuatu', 'wallis and futuna', 'samoa', 'kosovo', 'yemen', 'mayotte', 'south africa', 'zambia', 'zimbabwe']] = 'united states',\n    watch: bool = False,\n    delisted: bool = False,\n    jurisdiction: str = 'US',\n    isin: Optional[str] = None,\n    strategy: Union[str, List[str]] = <factory>,\n    strategy_comments: Optional[str] = None\n)", "funcdef": "def"}, {"fullname": "tessa.symbol.extended_symbol.ExtendedSymbol.description", "modulename": "tessa.symbol.extended_symbol", "qualname": "ExtendedSymbol.description", "type": "variable", "doc": "<p>Informational only.</p>\n", "annotation": ": Optional[str]", "default_value": " = None"}, {"fullname": "tessa.symbol.extended_symbol.ExtendedSymbol.country", "modulename": "tessa.symbol.extended_symbol", "qualname": "ExtendedSymbol.country", "type": "variable", "doc": "<p>Country of HQ / listing.</p>\n", "annotation": ": Optional[Literal['andorra', 'united arab emirates', 'afghanistan', 'antigua and barbuda', 'anguilla', 'albania', 'armenia', 'angola', 'antarctica', 'argentina', 'american samoa', 'austria', 'australia', 'aruba', '\u00e5land', 'azerbaijan', 'bosnia and herzegovina', 'barbados', 'bangladesh', 'belgium', 'burkina faso', 'bulgaria', 'bahrain', 'burundi', 'benin', 'saint barth\u00e9lemy', 'bermuda', 'brunei', 'bolivia', 'bonaire', 'brazil', 'bahamas', 'bhutan', 'bouvet island', 'botswana', 'belarus', 'belize', 'canada', 'cocos [keeling] islands', 'democratic republic of the congo', 'central african republic', 'republic of the congo', 'switzerland', 'ivory coast', 'cook islands', 'chile', 'cameroon', 'china', 'colombia', 'costa rica', 'cuba', 'cape verde', 'curacao', 'christmas island', 'cyprus', 'czech republic', 'germany', 'djibouti', 'denmark', 'dominica', 'dominican republic', 'algeria', 'ecuador', 'estonia', 'egypt', 'western sahara', 'eritrea', 'spain', 'ethiopia', 'finland', 'fiji', 'falkland islands', 'micronesia', 'faroe islands', 'france', 'gabon', 'united kingdom', 'grenada', 'georgia', 'french guiana', 'guernsey', 'ghana', 'gibraltar', 'greenland', 'gambia', 'guinea', 'guadeloupe', 'equatorial guinea', 'greece', 'south georgia and the south sandwich islands', 'guatemala', 'guam', 'guinea-bissau', 'guyana', 'hong kong', 'heard island and mcdonald islands', 'honduras', 'croatia', 'haiti', 'hungary', 'indonesia', 'ireland', 'israel', 'isle of man', 'india', 'british indian ocean territory', 'iraq', 'iran', 'iceland', 'italy', 'jersey', 'jamaica', 'jordan', 'japan', 'kenya', 'kyrgyzstan', 'cambodia', 'kiribati', 'comoros', 'saint kitts and nevis', 'north korea', 'south korea', 'kuwait', 'cayman islands', 'kazakhstan', 'laos', 'lebanon', 'saint lucia', 'liechtenstein', 'sri lanka', 'liberia', 'lesotho', 'lithuania', 'luxembourg', 'latvia', 'libya', 'morocco', 'monaco', 'moldova', 'montenegro', 'saint martin', 'madagascar', 'marshall islands', 'north macedonia', 'mali', 'myanmar [burma]', 'mongolia', 'macao', 'northern mariana islands', 'martinique', 'mauritania', 'montserrat', 'malta', 'mauritius', 'maldives', 'malawi', 'mexico', 'malaysia', 'mozambique', 'namibia', 'new caledonia', 'niger', 'norfolk island', 'nigeria', 'nicaragua', 'netherlands', 'norway', 'nepal', 'nauru', 'niue', 'new zealand', 'oman', 'panama', 'peru', 'french polynesia', 'papua new guinea', 'philippines', 'pakistan', 'poland', 'saint pierre and miquelon', 'pitcairn islands', 'puerto rico', 'palestine', 'portugal', 'palau', 'paraguay', 'qatar', 'r\u00e9union', 'romania', 'serbia', 'russia', 'rwanda', 'saudi arabia', 'solomon islands', 'seychelles', 'sudan', 'sweden', 'singapore', 'saint helena', 'slovenia', 'svalbard and jan mayen', 'slovakia', 'sierra leone', 'san marino', 'senegal', 'somalia', 'suriname', 'south sudan', 's\u00e3o tom\u00e9 and pr\u00edncipe', 'el salvador', 'sint maarten', 'syria', 'swaziland', 'turks and caicos islands', 'chad', 'french southern territories', 'togo', 'thailand', 'tajikistan', 'tokelau', 'east timor', 'turkmenistan', 'tunisia', 'tonga', 'turkey', 'trinidad and tobago', 'tuvalu', 'taiwan', 'tanzania', 'ukraine', 'uganda', 'u.s. minor outlying islands', 'united states', 'uruguay', 'uzbekistan', 'vatican city', 'saint vincent and the grenadines', 'venezuela', 'british virgin islands', 'u.s. virgin islands', 'vietnam', 'vanuatu', 'wallis and futuna', 'samoa', 'kosovo', 'yemen', 'mayotte', 'south africa', 'zambia', 'zimbabwe']]", "default_value": " = 'united states'"}, {"fullname": "tessa.symbol.extended_symbol.ExtendedSymbol.watch", "modulename": "tessa.symbol.extended_symbol", "qualname": "ExtendedSymbol.watch", "type": "variable", "doc": "<p>Whether the ticker can produce alerts.</p>\n", "annotation": ": bool", "default_value": " = False"}, {"fullname": "tessa.symbol.extended_symbol.ExtendedSymbol.delisted", "modulename": "tessa.symbol.extended_symbol", "qualname": "ExtendedSymbol.delisted", "type": "variable", "doc": "<p>Used to filter certain symbols from analysis.</p>\n", "annotation": ": bool", "default_value": " = False"}, {"fullname": "tessa.symbol.extended_symbol.ExtendedSymbol.jurisdiction", "modulename": "tessa.symbol.extended_symbol", "qualname": "ExtendedSymbol.jurisdiction", "type": "variable", "doc": "<p>main jurisdiction of the underlying asset(s) (not of the title representing the\nasset); default US, other examples: CN, EU, several, irrelevant, unknown</p>\n", "annotation": ": str", "default_value": " = 'US'"}, {"fullname": "tessa.symbol.extended_symbol.ExtendedSymbol.isin", "modulename": "tessa.symbol.extended_symbol", "qualname": "ExtendedSymbol.isin", "type": "variable", "doc": "<p>Informational only.</p>\n", "annotation": ": Optional[str]", "default_value": " = None"}, {"fullname": "tessa.symbol.extended_symbol.ExtendedSymbol.strategy", "modulename": "tessa.symbol.extended_symbol", "qualname": "ExtendedSymbol.strategy", "type": "variable", "doc": "<p>One strategy or a list of several strategies. Some strategies I use:</p>\n\n<ul>\n<li>F&amp;F: Fire &amp; Forget (implies HoldForGrowth)</li>\n<li>HoldForGrowth</li>\n<li>HoldForStability: low growth expected, but also low risk</li>\n<li>HoldForDiversification: titles I find important for diversification</li>\n<li>EnterIf: consider starting a position if prices for this title fall</li>\n<li>SellIf: consider selling if prices high and/or liquidity needed</li>\n<li>Sold: earlier holding that was sold at some point</li>\n<li>Quarterly: quarterly invest</li>\n</ul>\n", "annotation": ": Union[str, List[str]]"}, {"fullname": "tessa.symbol.extended_symbol.ExtendedSymbol.strategy_comments", "modulename": "tessa.symbol.extended_symbol", "qualname": "ExtendedSymbol.strategy_comments", "type": "variable", "doc": "<p>Additional comments re strategy.</p>\n", "annotation": ": Optional[str]", "default_value": " = None"}, {"fullname": "tessa.symbol.extended_symbol.ExtendedSymbol.region", "modulename": "tessa.symbol.extended_symbol", "qualname": "ExtendedSymbol.region", "type": "variable", "doc": "<p>Will be set automatically.</p>\n", "annotation": ": str"}, {"fullname": "tessa.symbol.extended_symbol.ExtendedSymbol.get_strategy_string", "modulename": "tessa.symbol.extended_symbol", "qualname": "ExtendedSymbol.get_strategy_string", "type": "function", "doc": "<p>Return a nice string with the strategy including comments.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "tessa.symbol.extended_symbol.ExtendedSymbol.price_graph", "modulename": "tessa.symbol.extended_symbol", "qualname": "ExtendedSymbol.price_graph", "type": "function", "doc": "<p>Add some extra information to the price graph.</p>\n", "signature": "(self, monthsback: int = 6) -> tuple", "funcdef": "def"}, {"fullname": "tessa.symbol.geo", "modulename": "tessa.symbol.geo", "type": "module", "doc": "<p>Geography helpers for <code>ExtendedSymbol</code>.</p>\n"}, {"fullname": "tessa.symbol.geo.countrynames", "modulename": "tessa.symbol.geo.countrynames", "type": "module", "doc": "<p><code>CountryName</code> type.</p>\n"}, {"fullname": "tessa.symbol.geo.jurisdiction2region", "modulename": "tessa.symbol.geo.jurisdiction2region", "type": "module", "doc": "<p>Jurisdiction to region mapping.</p>\n"}, {"fullname": "tessa.symbol.geo.jurisdiction2region.map_jurisdiction_to_region", "modulename": "tessa.symbol.geo.jurisdiction2region", "qualname": "map_jurisdiction_to_region", "type": "function", "doc": "<p>Map jurisdiction to region.</p>\n", "signature": "(jur: str) -> str", "funcdef": "def"}, {"fullname": "tessa.symbol.symbol", "modulename": "tessa.symbol.symbol", "type": "module", "doc": "<p>Symbol class.</p>\n"}, {"fullname": "tessa.symbol.symbol.Symbol", "modulename": "tessa.symbol.symbol", "qualname": "Symbol", "type": "class", "doc": "<p>Symbol class. Encapsulates all the relevant information around a financial symbol\nand some functionality to get price information, display graphs, etc.</p>\n\n<p>Notes:</p>\n\n<ul>\n<li>Price-related functions rely on caching happening on lower levels to be efficient;\nthis is fulfilled thanks to the way tessa's caching works.</li>\n<li>The initializers don't hit the network -- it will only be hit when accessing the\nprice methods or related methods such as <code>currency</code>.</li>\n</ul>\n"}, {"fullname": "tessa.symbol.symbol.Symbol.__init__", "modulename": "tessa.symbol.symbol", "qualname": "Symbol.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    name: str,\n    query: Optional[str] = None,\n    source: Literal['yahoo', 'coingecko'] = 'yahoo',\n    aliases: list[str] = <factory>\n)", "funcdef": "def"}, {"fullname": "tessa.symbol.symbol.Symbol.name", "modulename": "tessa.symbol.symbol", "qualname": "Symbol.name", "type": "variable", "doc": "<p>Symbol's name and default query.</p>\n", "annotation": ": str"}, {"fullname": "tessa.symbol.symbol.Symbol.query", "modulename": "tessa.symbol.symbol", "qualname": "Symbol.query", "type": "variable", "doc": "<p>Use this to use a query that is different than the name. <code>name</code> will be used as\nthe <code>query</code> if it is <code>None</code>.</p>\n", "annotation": ": Optional[str]", "default_value": " = None"}, {"fullname": "tessa.symbol.symbol.Symbol.source", "modulename": "tessa.symbol.symbol", "qualname": "Symbol.source", "type": "variable", "doc": "<p>The source to query for this symbol. Defaults to \"yahoo\".</p>\n", "annotation": ": Literal['yahoo', 'coingecko']", "default_value": " = 'yahoo'"}, {"fullname": "tessa.symbol.symbol.Symbol.aliases", "modulename": "tessa.symbol.symbol", "qualname": "Symbol.aliases", "type": "variable", "doc": "<p>Optional other names this symbol should be found under. (Will not be used as\nadditional queries but \"internally\" in the <code>matches</code> method.)</p>\n", "annotation": ": list[str]"}, {"fullname": "tessa.symbol.symbol.Symbol.currency_preference", "modulename": "tessa.symbol.symbol", "qualname": "Symbol.currency_preference", "type": "variable", "doc": "<p>Use this to set the preferred currency to get price information in.</p>\n\n<p>This is no guarantee and you should always double-check the currency that gets\nreturned by any of the <code>price_*</code> methods in actuality. This is also the reason why\nthis feature is slightly hidden behind an underscore.</p>\n\n<p>Since this is a class variable, you can set your preference once for all objects.</p>\n", "annotation": ": ClassVar[str]", "default_value": " = 'USD'"}, {"fullname": "tessa.symbol.symbol.Symbol.p", "modulename": "tessa.symbol.symbol", "qualname": "Symbol.p", "type": "function", "doc": "<p>Convenience method to print the symbol.</p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "tessa.symbol.symbol.Symbol.to_yaml", "modulename": "tessa.symbol.symbol", "qualname": "Symbol.to_yaml", "type": "function", "doc": "<p>Return a YAML representation of this symbol.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "tessa.symbol.symbol.Symbol.currency", "modulename": "tessa.symbol.symbol", "qualname": "Symbol.currency", "type": "function", "doc": "<p>Return currency for this symbol.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "tessa.symbol.symbol.Symbol.price_latest", "modulename": "tessa.symbol.symbol", "qualname": "Symbol.price_latest", "type": "function", "doc": "<p>Return the latest close price.</p>\n", "signature": "(self) -> tessa.price.types.PricePoint", "funcdef": "def"}, {"fullname": "tessa.symbol.symbol.Symbol.price_history", "modulename": "tessa.symbol.symbol", "qualname": "Symbol.price_history", "type": "function", "doc": "<p>Return a tuple of the full price history.</p>\n", "signature": "(self) -> tessa.price.types.PriceHistory", "funcdef": "def"}, {"fullname": "tessa.symbol.symbol.Symbol.price_point", "modulename": "tessa.symbol.symbol", "qualname": "Symbol.price_point", "type": "function", "doc": "<p>Look up price at given date <code>when</code>. Look for the closest point in time if the\nexact point in time is not found.</p>\n", "signature": "(\n    self,\n    when: Union[str, pandas._libs.tslibs.timestamps.Timestamp]\n) -> tessa.price.types.PricePoint", "funcdef": "def"}, {"fullname": "tessa.symbol.symbol.Symbol.price_graph", "modulename": "tessa.symbol.symbol", "qualname": "Symbol.price_graph", "type": "function", "doc": "<p>Display this symbol's price graph over the last monthsback months.</p>\n\n<p>Returns from_date, fig, and ax in order for subclass functions to add to the\ninformation and even the graph displayed here.</p>\n", "signature": "(self, monthsback: int = 6) -> tuple", "funcdef": "def"}, {"fullname": "tessa.symbol.symbol.Symbol.matches", "modulename": "tessa.symbol.symbol", "qualname": "Symbol.matches", "type": "function", "doc": "<p>Check if <code>what</code> matches this symbol's name or aliases. Also tries to match\nthings like SPICHA if SPICHA.SW is in the aliases. Ignores case.</p>\n", "signature": "(self, what: str) -> bool", "funcdef": "def"}, {"fullname": "tessa.symbol.symbolcollection", "modulename": "tessa.symbol.symbolcollection", "type": "module", "doc": "<p>SymbolCollection class.</p>\n"}, {"fullname": "tessa.symbol.symbolcollection.SymbolCollection", "modulename": "tessa.symbol.symbolcollection", "qualname": "SymbolCollection", "type": "class", "doc": "<p>A collection of <code>Symbol</code>s. A <code>Symbol</code>'s name is treated as a key in a collection\nand this class enforces as much in the <code>add</code> method.</p>\n"}, {"fullname": "tessa.symbol.symbolcollection.SymbolCollection.__init__", "modulename": "tessa.symbol.symbolcollection", "qualname": "SymbolCollection.__init__", "type": "function", "doc": "<p>Initializer. Use <code>symbols</code> to add symbols immediately and/or use <code>add</code> method\nlater.</p>\n", "signature": "(self, symbols: Optional[List[tessa.symbol.symbol.Symbol]] = None)", "funcdef": "def"}, {"fullname": "tessa.symbol.symbolcollection.SymbolCollection.symbols", "modulename": "tessa.symbol.symbolcollection", "qualname": "SymbolCollection.symbols", "type": "variable", "doc": "<p>The <code>Symbol</code>s in the collection.</p>\n", "annotation": ": List[tessa.symbol.symbol.Symbol]"}, {"fullname": "tessa.symbol.symbolcollection.SymbolCollection.add", "modulename": "tessa.symbol.symbolcollection", "qualname": "SymbolCollection.add", "type": "function", "doc": "<p>Add symbols to the collection. Ensure names are unique.</p>\n", "signature": "(\n    self,\n    symbols: Union[tessa.symbol.symbol.Symbol, List[tessa.symbol.symbol.Symbol]]\n) -> tessa.symbol.symbolcollection.SymbolCollection", "funcdef": "def"}, {"fullname": "tessa.symbol.symbolcollection.SymbolCollection.find_one", "modulename": "tessa.symbol.symbolcollection", "qualname": "SymbolCollection.find_one", "type": "function", "doc": "<p>Find exactly one <code>Symbol</code> that matches the query. Raises <code>ValueError</code> if\nthere's more than 1 match. Returns <code>None</code> if there's no match.</p>\n", "signature": "(self, what: str) -> Optional[tessa.symbol.symbol.Symbol]", "funcdef": "def"}, {"fullname": "tessa.symbol.symbolcollection.SymbolCollection.find", "modulename": "tessa.symbol.symbolcollection", "qualname": "SymbolCollection.find", "type": "function", "doc": "<p>Find all <code>Symbol</code>s that match the query.</p>\n", "signature": "(self, what: str) -> List[tessa.symbol.symbol.Symbol]", "funcdef": "def"}, {"fullname": "tessa.symbol.symbolcollection.SymbolCollection.load_yaml", "modulename": "tessa.symbol.symbolcollection", "qualname": "SymbolCollection.load_yaml", "type": "function", "doc": "<p>Load symbols from a YAML file.</p>\n\n<ul>\n<li><code>yaml_file</code>: Name/path of file to load.</li>\n<li><code>which_class</code>: The class to be instantiated, can be used to instatiate\nsubclasses of <code>Symbol</code>.</li>\n</ul>\n", "signature": "(\n    self,\n    yaml_file: str,\n    which_class: Type[tessa.symbol.symbol.Symbol] = <class 'tessa.symbol.symbol.Symbol'>\n) -> None", "funcdef": "def"}, {"fullname": "tessa.symbol.symbolcollection.SymbolCollection.to_yaml", "modulename": "tessa.symbol.symbolcollection", "qualname": "SymbolCollection.to_yaml", "type": "function", "doc": "<p>Return a YAML representation of all symbols.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "tessa.symbol.symbolcollection.SymbolCollection.save_yaml", "modulename": "tessa.symbol.symbolcollection", "qualname": "SymbolCollection.save_yaml", "type": "function", "doc": "<p>Save symbols to a YAML file.</p>\n", "signature": "(self, yaml_file: str) -> None", "funcdef": "def"}, {"fullname": "tessa.utils", "modulename": "tessa.utils", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tessa.utils.freezeargs", "modulename": "tessa.utils.freezeargs", "type": "module", "doc": "<p><code>freezeargs</code> decorator.</p>\n"}, {"fullname": "tessa.utils.freezeargs.freeze", "modulename": "tessa.utils.freezeargs", "qualname": "freeze", "type": "function", "doc": "<p>Freeze object.</p>\n", "signature": "(x: object) -> object", "funcdef": "def"}, {"fullname": "tessa.utils.freezeargs.freezeargs", "modulename": "tessa.utils.freezeargs", "qualname": "freezeargs", "type": "function", "doc": "<p>Transform mutable dictionary into immutable useful to be compatible with cache.</p>\n\n<p>Based on:\n<a href=\"https://stackoverflow.com/questions/6358481/using-functools-lru-cache-with-dictionary-arguments\">https://stackoverflow.com/questions/6358481/using-functools-lru-cache-with-dictionary-arguments</a></p>\n", "signature": "(func: <built-in function callable>) -> <built-in function callable>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();